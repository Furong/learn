### 最快的int-to-int HashMap实现

这篇文章将一步一步地介绍最新的hash map实现中一些技巧。在这篇文章的最后，你将获得最快的int-to-int hash map的Java实现。

open indexing开放索引

大多数现代哈希映射都基于开放索引的思想。这是什么意思？你的map基于键的数组（值将始终放在匹配的数组索引处，因此暂时忘记它们）。必须在每个map操作的键的数组中找到你的键。它是如何实现的？

首先，您需要在数组中的初始查找位置。它可以通过将键映射到该范围内的整数的任何函数来计算`[0, array.length - 1]`。键值通常通过方法映射到整数`hashCode`。这里最简单的功能可能是`Math.abs(key.hashCode() % array.length)`（请记住，`%`结果可能是负面的）。

如您所知，将大量键集映射为一小组整数值意味着您可能最终会遇到一些冲突（它们称为哈希冲突） - 不同键的初始函数的结果相同。通过尝试将另一个函数应用于原始数组索引来解决冲突。最简单的这类功能是`(prevIdx + 1) % array.length`。这些函数有一个要求 - 如果在循环中应用，它们应覆盖整个集合或阵列单元，以便您可以使用整个阵列容量。如果数组长度是另一个素数，则此类函数的另一个示例是将索引递增一个素数。



#### 参考链接

<http://java-performance.info/implementing-world-fastest-java-int-to-int-hash-map/>

